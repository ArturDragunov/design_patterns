import threading
#%% Lazy instantiation
class SingletonMetaLazy(type):
  # Dictionary stores single instance of the class for each subclass of the SingletonMeta metaclass
  _instances = {}
  _lock = threading.Lock()

# __call__ method is triggered every time you use class constructor!
# It's a special method in Python that gets automatically
# called when you try to "call" a class as if it were a function.    
  
  def __call__(cls, *args, **kwargs):
    # Acquire the lock to ensure thread safety
    with cls._lock:
        # Check if an instance has already been created
      if cls not in cls._instances:
        # Create the instance by calling the parent's call method
        # super() here refers to type
        # This calls the original type.__call__() method
        # which creates a new instance of the class
        instance = super().__call__(*args, **kwargs)
        cls._instances[cls] = instance
      return cls._instances[cls]
class NumberSequenceGeneratorLazy(metaclass = SingletonMetaLazy):
  # TODO 1: Implement a private constructor
  # - Ensure it can only be called internally
  # - Initialize the starting number (e.g., 0)
  # - Add a mechanism to track the current number in sequence
  def __init__(self):
    self.__current_number = 0 # private attribute
  # TODO 2: Implement method to get next number in sequence
  # - Increment and return the next number
  # - Ensure thread-safety is considered (we'll handle this in Exercise 2)
  def getNextNumber(self):
    with self.__class__._lock:
      self.__current_number += 1
      next_number = self.__current_number
    return next_number
  # TODO 3: Optional: Add a method to reset the sequence if needed
  def resetSequence(self):
     self.__current_number = 0
     return self.__current_number

#%% Eager instantiation
class SingletonMetaEager(type):
    # Initialize a dictionary to store instances of the Singleton class
    _instances = {}
    _lock = threading.Lock()

    # Override the __new__ method instantate the class at load time
    def __new__(cls, *args, **kwargs):
      with cls._lock:
        print('initializing <super>...')
        new_class = super().__new__(cls, *args, **kwargs)
        cls._instances[new_class] = super(SingletonMetaEager, new_class).__call__()
        return new_class

    # Return already initialized instance: Eager Loading
    def __call__(cls, *args, **kwargs):
      return cls._instances[cls]
class NumberSequenceGeneratorEager(metaclass = SingletonMetaEager):
  def __init__(self):
    self.__current_number = 0 # private attribute

  def getNextNumber(self):
    with self.__class__._lock:
      self.__current_number += 1
      next_number = self.__current_number
    return next_number

  def resetSequence(self):
    self.__current_number = 0
    return self.__current_number
  
#%% Stress-testing
import threading
import time

def stress_test_generator(generator, results, thread_id):
  # List to store numbers generated by this thread
  thread_numbers = []
  
  # Each thread calls getNextNumber 100 times
  for _ in range(100):
    next_num = generator.getNextNumber()
    thread_numbers.append(next_num)
  
  # Store results for later verification
  results[thread_id] = thread_numbers

def run_singleton_stress_test(generator_class):
  # Create generator instance
  generator = generator_class()
  
  # Dictionary to store results from each thread
  results = {}
  
  # Create multiple threads
  threads = []
  for i in range(10):  # 10 threads
    thread = threading.Thread(target=stress_test_generator, 
                               args=(generator, results, i))
    threads.append(thread)
  
  # Start all threads
  for thread in threads:
    thread.start()
  
  # Wait for all threads to complete
  for thread in threads:
    thread.join()
  
  # Verify results
  all_numbers = []
  for thread_id, thread_nums in results.items():
    all_numbers.extend(thread_nums)
  
  # Check uniqueness and sequence
  print("Total numbers generated:", len(all_numbers))
  print("Unique numbers:", len(set(all_numbers)))
  print("Min number:", min(all_numbers))
  print("Max number:", max(all_numbers))
  
  # Verify no duplicates and correct sequence
  assert len(all_numbers) == len(set(all_numbers)), "Duplicate numbers detected!"
  assert all_numbers == list(range(1, len(all_numbers) + 1)), "Sequence is broken!"
  print("Stress test passed successfully!")

# Run stress test for both Lazy and Eager instantiation
print("Stress Test for Lazy Instantiation:")
run_singleton_stress_test(NumberSequenceGeneratorLazy)

print("\nStress Test for Eager Instantiation:")
run_singleton_stress_test(NumberSequenceGeneratorEager)
